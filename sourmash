#! /usr/bin/env python
from __future__ import print_function
import sys
import os
import argparse
import screed
import sourmash_lib
from sourmash_lib import signature as sig

DEFAULT_K = 32
DEFAULT_N = 500
DEFAULT_COMPOSITE_N = 500


class SourmashCommands(object):

    def __init__(self):
        parser = argparse.ArgumentParser(description='work with RNAseq signatures',
                                         usage='''sourmash <command> [<args>]

Commands can be:

   compute <filenames>         Compute signatures for sequences in these files.
   compare <filenames.sig>     Compute distance matrix for given signatures.
   search <query> <against>    Search for matching signatures.
.
''')
        parser.add_argument('command')
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print('Unrecognized command')
            parser.print_help()
            sys.exit(1)

        cmd = getattr(self, args.command)
        print('# running sourmash subcommand: %s' % args.command)
        cmd()

    def search(self):
        "Search a query sig against one or more signatures; report top match."
        parser = argparse.ArgumentParser()
        parser.add_argument('query')
        parser.add_argument('against', nargs='+')
        parser.add_argument('--threshold', default=0.08, type=float)
        parser.add_argument('-k', '--ksize', default=DEFAULT_K, type=int)
        args = parser.parse_args(sys.argv[2:])

        sl = sig.load_signatures(
            open(args.query, 'r'), select_ksize=args.ksize)
        if len(sl) != 1:
            raise Exception("%d query signatures; need exactly one" % len(sl))
        query = sl[0]

        print('loading signatures from %d files' % len(args.against))
        against = []
        for filename in args.against:
            if filename == args.query:
                print('excluding query from database (file %s)' % filename)
                continue

            sl = sig.load_signatures(
                open(filename, 'r'), select_ksize=args.ksize)
            for x in sl:
                against.append((x, filename))

        distances = []
        for (x, filename) in against:
            distance = query.similarity(x)
            if distance >= args.threshold:
                distances.append((distance, x, filename))

        if distances:
            distances.sort(reverse=True)
            print('%d matches:' % len(distances))
            for distance, match, filename in distances[:3]:
                print('\t', match.name(), '\t', "%.3f" % distance,
                      '\t', filename)
        else:
            print('** no matches in %d signatures' % len(against))

    def compute(self):
        "Compute the signature for one or more files."
        parser = argparse.ArgumentParser()
        parser.add_argument('--protein', action='store_true')
        parser.add_argument('--input-is-protein', action='store_true')
        parser.add_argument('filenames', nargs='+')
        parser.add_argument('-k', '--ksizes',
                            default=str(DEFAULT_K),
                            help='comma-separated list of k-mer sizes')
        parser.add_argument('-n', '--num-hashes', type=int,
                            default=DEFAULT_N,
                            help='number of hashes to use in each sketch')
        parser.add_argument('-f', '--force', action='store_true')
        args = parser.parse_args(sys.argv[2:])

        print('computing signatures for files:', args.filenames)

        ksizes = args.ksizes
        if ',' in ksizes:
            ksizes = ksizes.split(',')
            ksizes = list(map(int, ksizes))
        else:
            ksizes = [int(ksizes)]

        print('Computing signature for ksizes: %s' % str(ksizes))

        for filename in args.filenames:
            sigfile = os.path.basename(filename) + '.sig'
            if os.path.exists(sigfile) and not args.force:
                print('skipping', filename, '- already done')
                continue

            Elist = []
            for k in ksizes:
                E = sourmash_lib.Estimators(ksize=k, n=args.num_hashes,
                                            protein=args.protein)
                Elist.append(E)

            for n, record in enumerate(screed.open(filename)):
                if n % 10000 == 0:
                    print('...', filename, n)
                if 0 and n % 100000 == 0 and n:
                    siglist = []
                    for E in Elist:
                        signature = sig.SourmashSignature('titus@idyll.org',
                                                          E,
                                                          filename=filename)
                        siglist.append(signature)

                    data = sig.save_signatures(siglist)
                    fp = open(sigfile + '.%d' % n, 'w')
                    fp.write(data)
                    fp.close()

                s = record.sequence
#            for i in 'R', 'W', 'Y': # sanitizing refseq mRNA
#               s = s.replace(i, 'N')
                for E in Elist:
                    if args.input_is_protein:
                        E.mh.add_protein(s)
                    else:
                        E.add_sequence(s)

            siglist = []
            for E in Elist:
                signature = sig.SourmashSignature('titus@idyll.org',
                                                  E,
                                                  filename=filename)
                siglist.append(signature)

            data = sig.save_signatures(siglist)
            fp = open(sigfile, 'w')
            fp.write(data)
            fp.close()

    def compare(self):
        "Compare multiple signature files and create a distance matrix."
        import numpy

        parser = argparse.ArgumentParser()
        parser.add_argument('signatures', nargs='+')
        parser.add_argument('-k', '--ksize', type=int, default=DEFAULT_K)
        parser.add_argument('-o', '--output-filename')
        parser.add_argument('-e', '--eliminate-singletons',
                            action='store_true')
        args = parser.parse_args(sys.argv[2:])

        siglist = []
        for filename in args.signatures:
            data = open(filename).read()
            print('loading', filename)
            loaded = sig.load_signatures(data, select_ksize=args.ksize)
            siglist.extend(loaded)

        if args.eliminate_singletons:
            start_sigs = len(siglist)

            def match_above_threshold(sig1, siglist):
                THRESHOLD = 0.05
                for sig2 in siglist:
                    if sig1 != sig2 and (sig1.similarity(sig2) > THRESHOLD or
                                         sig2.similarity(sig1) > THRESHOLD):
                        return True
                return False

            siglist = [s for s in siglist if match_above_threshold(s, siglist)]
            print('eliminated %d sigs (of %d)' % (len(siglist) - start_sigs,
                                                  start_sigs))

        if len(siglist) == 0:
            print('no signatures!')
            sys.exit(-1)

        D = numpy.zeros([len(siglist), len(siglist)])
        numpy.set_printoptions(precision=3, suppress=True)

        i = 0
        labeltext = []
        samples = []
        for E in siglist:
            j = 0
            for E2 in siglist:
                D[i][j] = E.similarity(E2)
                j += 1

            print('%d-%20s\t%s' % (i, E.name(), D[i, :, ],))
            labeltext.append(E.name())
            i += 1

        print('min similarity in matrix:', numpy.min(D))
        # print('max similarity in matrix:', numpy.max(D))

        if args.output_filename:
            labeloutname = args.output_filename + '.labels.txt'
            print('saving labels to:', labeloutname)
            fp = open(labeloutname, 'w')
            fp.write("\n".join(labeltext))
            fp.close()

            print('saving distance matrix to:', args.output_filename)
            fp = open(args.output_filename, 'wb')
            numpy.save(fp, D)
            fp.close()


def main():
    SourmashCommands()

if __name__ == '__main__':
    main()
